<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ML:Tarea2</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="mltarea2-eduardo-acuña-yeomans">ML:Tarea2 - Eduardo Acuña Yeomans</h1>



<h2 id="1-qué-es-aprendizaje-máquina">1. ¿Qué es aprendizaje máquina?</h2>



<h4 id="1-qué-tipo-de-aprendizaje-si-aplica-describe-mejor-los-siguientes-problemas">1. ¿Qué tipo de <em>aprendizaje</em> (si aplica) describe mejor los siguientes problemas? :</h4>



<h5 id="a-un-sistema-de-clasificación-automática-de-monedas-para-realizar-el-sistema-los-desarrolladores-obtuvieron-las-especificaciones-exactas-del-banco-de-méxico-sobre-las-monedas-de-1-2-5-y-10-pesos-con-estas-especificaciones-desarrollaron-un-modelo-estadístico-basado-en-el-peso-tamaño-y-denominación">a) Un sistema de clasificación automática de monedas. Para realizar el sistema, los desarrolladores obtuvieron las especificaciones exactas del Banco de México sobre las monedas de <script type="math/tex" id="MathJax-Element-1">1</script>, <script type="math/tex" id="MathJax-Element-2">2</script>, <script type="math/tex" id="MathJax-Element-3">5</script> y <script type="math/tex" id="MathJax-Element-4">10</script> pesos. Con estas especificaciones desarrollaron un modelo estadístico basado en el peso, tamaño y denominación.</h5>

<blockquote>
  <p>El <strong>aprendizaje supervisado</strong> sería mejor ya que conocemos el conjunto de clasificaciones.</p>
</blockquote>



<h5 id="b-para-un-sistema-simple-en-lugar-de-utilizar-las-especificaciones-se-utilizo-un-conjunto-de-monedas-a-las-cuales-se-les-midió-peso-y-tamaño-el-algoritmo-utiliza-esta-información-para-encontrar-umbrales-que-permitan-distinguir-una-moneda-de-otra-de-diferente">b)  Para un sistema simple, en lugar de utilizar las especificaciones, se utilizo un conjunto de monedas a las cuales se les midió peso y tamaño. El algoritmo utiliza esta información para encontrar umbrales que permitan distinguir una moneda de otra de diferente.</h5>

<blockquote>
  <p>En este caso considero que el mejor es el <strong>aprendizaje no supervisado</strong>, no conocemos que denominaciones hay, pudiera haber o de <span>$</span>1.00, <span>$</span>200, <span>$</span>5.00 o de <span>$</span>5.00, <span>$</span>10.00, <span>$</span>20.00 o incluso monedas chafonas poker o algo así y tendríamos que identificar cuales son los tipos de monedas en el conjunto.</p>
</blockquote>



<h5 id="c-un-juego-computacional-que-desarrolla-en-forma-independiante-una-estrategia-para-ganar-a-partir-de-jugar-muchas-partidas-en-forma-automática-penalizando-las-partidas-que-pierde">c)  Un juego computacional que desarrolla en forma independiante una estrategia para ganar a partir de jugar muchas partidas en forma automática, penalizando las partidas que pierde.</h5>

<blockquote>
  <p>En este caso el mejor tipo de aprendizaje es el <strong>aprendizaje por refuerzo</strong> ya que cada partida que juega va mejorando su estrategia la cual es calificada con algun criterio.</p>
</blockquote>



<h4 id="2-cuales-de-los-siguientes-problemas-la-mejor-forma-de-resolverlos-es-con-aprendizaje-máquina">2.  ¿Cuales de los siguientes problemas, la mejor forma de resolverlos es con <em>aprendizaje máquina</em>?</h4>



<h5 id="a-clasificar-números-en-primos-y-no-primos">a) Clasificar números en primos y no primos.</h5>

<blockquote>
  <p>No conviene usar aprendizaje máquina, la definición de un número primo es bastante precisa y algoritmos deterministas bastante eficientes se han desarrollado para determinar si un número es primo o no. Además, he leído que no se ha encontrado un patrón en la distribución de números primos en <script type="math/tex" id="MathJax-Element-5">\mathbb{R}</script>. </p>
  
  <p>(Nada mas quería calar como se veían las letras nice con <script type="math/tex" id="MathJax-Element-6">\LaTeX</script> utilizando markdown)</p>
</blockquote>



<h5 id="b-detectar-un-probable-fraude-en-una-transacción-bancaria">b) Detectar un probable fraude en una transacción bancaria.</h5>

<blockquote>
  <p>En este caso se me hace confuso responser, no se como funcionen las transacciones bancarias. Pero me suenta que si las transacciones son un desastre de datos y la inconsistencia en los datos está muy escondida dentro de un mar de información, el aprendizaje máquina pudiera ayudar. Tal vez considerando un conjunto de transacciones no fraudulentas y checar si la transacción en cuestión difiere.</p>
</blockquote>



<h5 id="c-determinar-el-tiempo-que-le-toma-a-un-objeto-caer-de-una-altura-dada">c) Determinar el tiempo que le toma a un objeto caer de una altura dada.</h5>

<blockquote>
  <p>No es conveniente utilizar aprendizaje máquina en este caso ya que hay ecuaciones deterministas que se computan con un par de operaciones para medir el tiempo que tarda en caer un objeto. </p>
</blockquote>



<h5 id="d-determinar-el-ciclo-óptimo-de-encendido-de-semáforos-en-una-intersección-con-mucho-tráfico">d) Determinar el ciclo óptimo de encendido de semáforos en una intersección con mucho tráfico.</h5>

<blockquote>
  <p>El ciclo óptimo no creo. Un ciclo lo suficientemente bueno: si. Esto lo comento ya hasta donde yo tengo conocimiento el tráfico no solo depende de una intersección, depende de toda una ciudad y del flujo de entrada y salida de automóviles a la ciudad. Además puede que haya cuestiones imprevistas para determinar el comportamiento del tráfico (por ejemplo accidentes o festivales o eventos que modifican el flujo de carros).</p>
</blockquote>



<h2 id="2-la-desigualdad-de-hoeffding">2. La desigualdad de Hoeffding</h2>



<h4 id="1-consideremos-una-urna-con-canicas-verdes-y-rojas-de-la-que-no-conozco-la-cantidad-total-de-canicas-pueden-ser-infinitas-la-probabilidad-de-sacar-una-canica-de-color-rojo-es-mu-055-iid-con-remplazo-esta-urna-puede-ser-vista-como-el-conjunto-de-valores-de-x-in-x-y-el-color-es-verde-si-la-hipótesis-escogida-h-tiene-el-mismo-resultado-de-la-función-f-en-este-caso-tenemos-una-hipótesis-cuyo-error-fuera-de-muestra-es-eouth-055-un-clasificador-pero-que-un-volado">1. Consideremos una urna con canicas verdes y rojas, de la que no conozco la cantidad total de canicas (pueden ser infinitas). La probabilidad de sacar una canica de color rojo es <script type="math/tex" id="MathJax-Element-7">\mu = 0,55</script> (i.i.d., con remplazo). Esta urna puede ser vista como el conjunto de valores de <script type="math/tex" id="MathJax-Element-8">x \in X</script> y el color es verde si la hipótesis escogida <script type="math/tex" id="MathJax-Element-9">h</script> tiene el mismo resultado de la función <script type="math/tex" id="MathJax-Element-10">f</script> . En este caso, tenemos una hipótesis cuyo error fuera de muestra es <script type="math/tex" id="MathJax-Element-11">E_{out}(h) = 0,55</script>. Un clasificador pero que un volado.</h4>



<h4 id="consideremos-que-solamente-conocemos-el-valor-de-10-canicas-10-ejemplos-para-entrenamiento">Consideremos que solamente conocemos el valor de <script type="math/tex" id="MathJax-Element-12">10</script> canicas (<script type="math/tex" id="MathJax-Element-13">10</script> ejemplos para entrenamiento).</h4>



<h5 id="1-cuál-es-la-probabilidad-que-nu-0-si-solamente-obtenemos-una-muestra-de-10-canicas-escribe-un-resultado-lo-más-aproximado-posible">1. ¿Cuál es la probabilidad que <script type="math/tex" id="MathJax-Element-14">\nu = 0</script> si solamente obtenemos una muestra de 10 canicas? Escribe un resultado lo más aproximado posible.</h5>

<blockquote>
  <p><script type="math/tex" id="MathJax-Element-15">\nu</script> es la fracción de canicas rojas, es decir, en la muestra hay <script type="math/tex" id="MathJax-Element-16">0</script> canicas rojas de <script type="math/tex" id="MathJax-Element-17">10</script> canicas. Esto implica que todas las canicas en la muestra son verdes.</p>
  
  <p>La probabilidad que deseamos calcular es la de obtener <script type="math/tex" id="MathJax-Element-18">0</script> rojas en una muestra de tamaño <script type="math/tex" id="MathJax-Element-19">10</script> cuando la probabilidad de sacar una canica roja es de <script type="math/tex" id="MathJax-Element-20">0.55</script>. Esto se resuelve con la función de probabilidad de la distribución <strong>binomial</strong> la cual consiste en realizar <script type="math/tex" id="MathJax-Element-21">N</script> ensayos de Bernoulli (sale roja o no) con probabilidad <script type="math/tex" id="MathJax-Element-22">p</script> (en este caso <script type="math/tex" id="MathJax-Element-23">p = 0.55</script>) en donde la función de probabilidad involucra la cantidad de aciertos <script type="math/tex" id="MathJax-Element-24">k</script> (que se saca bola roja) encontrados en la muestra.<script type="math/tex; mode=display" id="MathJax-Element-25">\dbinom{N}{k}p^{k}(1-p)^{N-k}</script> Al enchufar los valores del problema en la expresión, nos resulta: <script type="math/tex; mode=display" id="MathJax-Element-26">\dbinom{10}{0}(0.55)^0(0.45)^{10}   = (0.45)^{10} = 0.000340506</script></p>
</blockquote>



<h5 id="2-cuál-es-la-probabilidad-de-encontrar-nu-0-al-menos-una-vez-si-tomamos-una-muestra-aleatoria-de-10-canicas-y-esto-lo-repetimos-1000-veces">2. ¿Cuál es la probabilidad de encontrar <script type="math/tex" id="MathJax-Element-27">\nu = 0</script> al menos una vez, si tomamos una muestra aleatoria de <script type="math/tex" id="MathJax-Element-28">10</script> canicas, y esto lo repetimos <script type="math/tex" id="MathJax-Element-29">1000</script> veces.</h5>

<blockquote>
  <p>Consideramos otro ensayo de Bernoulli en donde las 10 canicas salen todas rojas o no. Sabemos que la probabilidad de que salgan todas verdes es <script type="math/tex" id="MathJax-Element-30">0.000340506</script>, se repite este ensayo de Bernoulli <script type="math/tex" id="MathJax-Element-31">1000</script> veces y buscamos encontrar la probabilidad de que ocurra al menos una vez, lo cual es equivalente a 1 - la probabilidad de que nunca ocurra, de nuevo utilizamos la binomial:<script type="math/tex; mode=display" id="MathJax-Element-32">1 - \dbinom{1000}{0}(0.000340506)^{0}(0.999659494)^{1000} = 1 - 0.711 = 0.289</script></p>
</blockquote>



<h2 id="3-el-perceptrón-y-el-error-en-muestra-y-fuera-de-muestra">3. El perceptrón y el error en muestra y fuera de muestra</h2>



<h4 id="1-para-contestar-las-preguntas-de-esta-sección-es-necesario-realizar-varios-programas-los-cuales-pueden-ser-programados-en-cualquier-lenguaje-de-programación-de-su-elección-los-únicos-lenguajes-de-programación-que-no-se-aceptan-son-brainfuck-y-whitespace">1. Para contestar las preguntas de esta sección es necesario realizar varios programas, los cuales pueden ser programados en cualquier lenguaje de programación de su elección. Los únicos lenguajes de programación que no se aceptan son <code>Brainfuck</code> y <code>Whitespace</code>.</h4>



<h5 id="1-realiza-una-funcion-que-reciba-tres-parámetros-flotantes-w0-w1-w2-y-dos-valores-x1-y-x2-y-devuelva-el-valor-signw1x1-w2x2-w0">1. Realiza una funcion que reciba tres parámetros flotantes <code>w0</code>, <code>w1</code>, <code>w2</code> y dos valores <code>x1</code> y <code>x2</code>, y devuelva el valor: <script type="math/tex; mode=display" id="MathJax-Element-33">sign(w_1x_1 + w_2x_2 + w_0)</script></h5>

<blockquote>
  <p>Implementación en Julia</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(w0, w1, w2, x1, x2)</span></span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sign</span>(w0 + w1*x1 + w2*x2)
<span class="hljs-keyword">end</span></code></pre>



<h5 id="2-realiza-una-función-que-genere-dos-pares-de-valores-p1-p11p12-y-p2-p21p22-tal-que-pij-sea-un-número-aleatorio-entre-0-y-1-con-una-distribución-uniforme-el-clasico-rand-de-prácticamente-todos-los-lenguajes-y-encuentre-los-valores-de-w0-w1-y-w2-tales-que-w1p11-w2p12w0-w1p21w2p22w0-0-estos-tres-parámetros-nos-definen-completamente-la-función-f">2. Realiza una función que genere dos pares de valores <script type="math/tex" id="MathJax-Element-34">p_1 = (p_{1,1},p_{1,2})</script> y <script type="math/tex" id="MathJax-Element-35">p_2 = (p_{2,1},p_{2,2})</script>, tal que <script type="math/tex" id="MathJax-Element-36">p_{i,j}</script> sea un número aleatorio entre <script type="math/tex" id="MathJax-Element-37">0</script> y <script type="math/tex" id="MathJax-Element-38">1</script> con una distribución uniforme (el clasico <code>rand</code> de prácticamente todos los lenguajes), y encuentre los valores de <script type="math/tex" id="MathJax-Element-39">w_0</script>, <script type="math/tex" id="MathJax-Element-40">w_1</script> y <script type="math/tex" id="MathJax-Element-41">w_2</script> tales que <script type="math/tex; mode=display" id="MathJax-Element-42">w_1p_{1,1} + w_2p_{1,2}+w_0 = w_1p_{2,1}+w_2p_{2,2}+w_0 = 0</script> Estos tres parámetros nos definen completamente la función <script type="math/tex" id="MathJax-Element-43">f</script>.</h5>

<blockquote>
  <p>Implementación en Julia</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>
  x = rand(<span class="hljs-number">2</span>)
  y = rand(<span class="hljs-number">2</span>)
  w2, w0 = <span class="hljs-string">[[x[2],y[2]]</span> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]\[-x[<span class="hljs-number">1</span>],-y[<span class="hljs-number">1</span>]]
  <span class="hljs-keyword">return</span> [w0, <span class="hljs-number">1</span>, w2]
<span class="hljs-keyword">end</span></code></pre>



<h5 id="3-realiza-una-función-que-genere-n-puntos-pi-pi1pi2-donde-cada-pij-es-un-numero-aleatorio-entre-0-y-1-con-distribución-uniforme">3. Realiza una función que genere <script type="math/tex" id="MathJax-Element-44">N</script> puntos <script type="math/tex" id="MathJax-Element-45">p_i = (p_{i,1},p_{i,2})</script> donde cada <script type="math/tex" id="MathJax-Element-46">p_{i,j}</script> es un numero aleatorio entre <script type="math/tex" id="MathJax-Element-47">0</script> y <script type="math/tex" id="MathJax-Element-48">1</script> con distribución uniforme.</h5>

<blockquote>
  <p>Implementación en Julia</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>
  ntuple(n, index-&gt;<span class="hljs-built_in">rand</span>(<span class="hljs-number">2</span>))
<span class="hljs-keyword">end</span></code></pre>



<h5 id="4-generaliza-la-función-del-inciso-1-para-asignar-clase-a-cada-uno-de-los-n-puntos-del-inciso-anterior">4. Generaliza la función del inciso 1, para asignar clase a cada uno de los <script type="math/tex" id="MathJax-Element-49">N</script> puntos del inciso anterior.</h5>

<blockquote>
  <p>Implementación en Julia</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">perceptron_responses</span><span class="hljs-params">(w, pts)</span></span>
  w0, w1, w2 = w
  map(p-&gt;(<span class="hljs-built_in">sign</span>(w0+w1*p<span class="hljs-matrix">[<span class="hljs-number">1</span>]</span>+w2*p<span class="hljs-matrix">[<span class="hljs-number">2</span>]</span>)), pts)
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">classified_data</span><span class="hljs-params">(n)</span></span>
  points = generate_data(n)
  w = random_line()
  <span class="hljs-keyword">return</span> perceptron_responses(w, points)
<span class="hljs-keyword">end</span></code></pre>



<h5 id="5-programa-el-algoritmo-del-perceptrón-para-encontrar-g-a-partir-de-los-n-datos-clasificados-encontrar-g-equivale-a-encontrar-los-parámetros-wg0-wg1-wg2-recuerda-que-para-un-conjunto-de-datos-linealmente-separables-el-algoritmo-del-perceptrón-siempre-encuentra-una-solución-g-tal-que-eing-0">5. Programa el algoritmo del perceptrón, para encontrar <script type="math/tex" id="MathJax-Element-109">g</script> a partir de los <script type="math/tex" id="MathJax-Element-110">N</script> datos clasificados. Encontrar <script type="math/tex" id="MathJax-Element-111">g</script> equivale a encontrar los parámetros <script type="math/tex" id="MathJax-Element-112">wg_0</script>, <script type="math/tex" id="MathJax-Element-113">wg_1</script>, <script type="math/tex" id="MathJax-Element-114">wg_2</script>. Recuerda que para un conjunto de datos linealmente separables, el algoritmo del perceptrón siempre encuentra una solución <script type="math/tex" id="MathJax-Element-115">g</script> tal que <script type="math/tex" id="MathJax-Element-116">E_{in}(g ) = 0</script>.</h5>

<blockquote>
  <p>Implementación en Julia</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-keyword">using</span> Gadfly

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random_line</span>()</span>
  x = rand(<span class="hljs-number">2</span>)
  y = rand(<span class="hljs-number">2</span>)
  w2, w0 = [[x[<span class="hljs-number">2</span>],y[<span class="hljs-number">2</span>]] [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]\[-x[<span class="hljs-number">1</span>],-y[<span class="hljs-number">1</span>]]
  <span class="hljs-constant">return</span> [w0, <span class="hljs-number">1</span>, w2]
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate_data</span>(<span class="hljs-title">n</span>)</span>
  data = Array(Array{Float64,<span class="hljs-number">1</span>}, n)
  <span class="hljs-keyword">for</span> i <span class="hljs-operator">in</span> <span class="hljs-number">1</span>:n
    data[i] = rand(<span class="hljs-number">2</span>)
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-constant">return</span> data
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">perceptron_responses</span>(<span class="hljs-title">w</span>, <span class="hljs-title">pts</span>)</span>
  w0, w1, w2 = w
  map(p-&gt;sign(w0+w1*p[<span class="hljs-number">1</span>]+w2*p[<span class="hljs-number">2</span>]), pts)
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">classified_data</span>(<span class="hljs-title">n</span>)</span>
  points = generate_data(n)
  w = random_line()
  classes = perceptron_responses(w, points)
  <span class="hljs-constant">return</span> points, classes, w
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">line_from_weights</span>(<span class="hljs-title">weights</span>)</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-title">x</span>)</span>
    -weights[<span class="hljs-number">1</span>]/weights[<span class="hljs-number">3</span>] - weights[<span class="hljs-number">2</span>]*x/weights[<span class="hljs-number">3</span>]
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-constant">return</span> f
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pla</span>(<span class="hljs-title">xs</span>, <span class="hljs-title">ys</span>, <span class="hljs-title">steps</span>)</span>
  <span class="hljs-comment"># initial random line</span>
  h = random_line()
  <span class="hljs-keyword">for</span> step <span class="hljs-operator">in</span> <span class="hljs-number">1</span>:steps
    cs = perceptron_responses(h, xs)
    <span class="hljs-keyword">for</span> i <span class="hljs-operator">in</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(cs)
      <span class="hljs-keyword">if</span> cs[i] != ys[i]
        h += ys[i]*[<span class="hljs-number">1</span>, xs[i]]
        break
      <span class="hljs-function"><span class="hljs-keyword">end</span></span>
    <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-constant">return</span> h
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pla</span>(<span class="hljs-title">xs</span>, <span class="hljs-title">ys</span>)</span>
  h = random_line()
  iteration = <span class="hljs-number">0</span>
  loop = <span class="hljs-constant">true</span>
  <span class="hljs-keyword">while</span> loop
    loop = <span class="hljs-constant">false</span>
    iteration += <span class="hljs-number">1</span>
    cs = perceptron_responses(h, xs)
    <span class="hljs-keyword">for</span> i <span class="hljs-operator">in</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(cs)
      <span class="hljs-keyword">if</span> cs[i] != ys[i]
        h += ys[i]*[<span class="hljs-number">1</span>, xs[i]]
        loop = <span class="hljs-constant">true</span>
        break
      <span class="hljs-function"><span class="hljs-keyword">end</span></span>
    <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-constant">return</span> h, iteration
<span class="hljs-function"><span class="hljs-keyword">end</span></span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pla_check</span>(<span class="hljs-title">cA</span>, <span class="hljs-title">cB</span>)</span>
  count(x-&gt;x[<span class="hljs-number">1</span>]!=x[<span class="hljs-number">2</span>], zip(cA,cB))
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pla_plot</span>(<span class="hljs-title">xs</span>, <span class="hljs-title">ys</span>, <span class="hljs-title">h</span>)</span>
  xline = linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
  yline = (line_from_weights(h))(xline)
  xdots = map(p-&gt;p[<span class="hljs-number">1</span>], xs)
  ydots = map(p-&gt;p[<span class="hljs-number">2</span>], xs)
  plot(layer(x=xline, y=yline, Geom.<span class="hljs-built_in">line</span>),
       layer(x=xdots, y=ydots, Geom.point, color=ys))
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-comment">#</span>
<span class="hljs-comment"># PERCEPTRON TEST</span>
<span class="hljs-comment"># </span>
xs, ys, f = classified_data(<span class="hljs-number">66</span>)
h, iterations = pla(xs, ys)
pla_check(ys, perceptron_responses(h, xs))
pla_plot(xs, ys, h)</code></pre>

<h5 id="6-programa-una-función-que-a-partir-de-la-caracterización-de-f-por-medio-de-w0-w1-w2-y-la-caracterización-de-g-con-wg0-wg1-wg2-calcule-eoutg-una-manera-de-estimar-el-error-fuera-de-muestra-es-un-un-metodo-tipo-montecarlo-a-la-fuerza-bruta-para-esto-se-genera-un-número-muy-grande-de-puntos-aleatorios-en-el-plano-unitrio-y-luego-se-calcula-el-porcentaje-de-error-mientras-más-puntos-se-generen-más-preciso-es-el-resultado">6. Programa una función que, a partir de la caracterización de <script type="math/tex" id="MathJax-Element-279">f</script> por medio de <script type="math/tex" id="MathJax-Element-280">w_0</script>, <script type="math/tex" id="MathJax-Element-281">w_1</script>, <script type="math/tex" id="MathJax-Element-282">w_2</script> y la caracterización de <script type="math/tex" id="MathJax-Element-283">g</script> con <script type="math/tex" id="MathJax-Element-284">wg_0</script>, <script type="math/tex" id="MathJax-Element-285">wg_1</script>, <script type="math/tex" id="MathJax-Element-286">wg_2</script> calcule <script type="math/tex" id="MathJax-Element-287">E_{out}(g )</script>. Una manera de estimar el error fuera de muestra es un un metodo tipo Montecarlo, a la fuerza bruta. Para esto, se genera un número muy grande de puntos aleatorios en el plano unitrio, y luego se calcula el porcentaje de error. Mientras más puntos se generen más preciso es el resultado.</h5>

<blockquote>
  <p>Implementación en Julia</p>
</blockquote>



<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">out_sample_error</span><span class="hljs-params">(f, h, n=1000)</span>
  <span class="hljs-title">points</span> = <span class="hljs-title">generate_data</span><span class="hljs-params">(n)</span>
  <span class="hljs-title">f_classes</span> = <span class="hljs-title">perceptron_responses</span><span class="hljs-params">(f, points)</span>
  <span class="hljs-title">h_classes</span> = <span class="hljs-title">perceptron_responses</span><span class="hljs-params">(h, points)</span>
  <span class="hljs-title">misses</span> = <span class="hljs-title">pla_check</span><span class="hljs-params">(f_classes, h_classes)</span>
  <span class="hljs-title">return</span> <span class="hljs-title">misses</span>/<span class="hljs-title">n</span>
<span class="hljs-title">end</span></span></code></pre>

<h4 id="2-con-estos-programas-desarrollados-y-probados-contesta-las-siguientes-preguntas">2. Con estos programas (desarrollados y probados) contesta las siguientes preguntas:</h4>



<h5 id="1-cuantas-iteraciones-le-toma-en-promedio-al-algoritmo-del-perceptrón-en-converger-para-diez-valores-en-el-conjunto-de-entrenamiento-n-10-para-tomar-un-número-promedio-de-iteraciones-hay-que-realizar-esto-al-menos-unas-100-veces">1. ¿Cuantas iteraciones le toma en promedio al algoritmo del perceptrón en converger, para diez valores en el conjunto de entrenamiento <script type="math/tex" id="MathJax-Element-359">N = 10</script>? Para tomar un número promedio de iteraciones hay que realizar esto al menos unas <script type="math/tex" id="MathJax-Element-360">100</script> veces.</h5>

<blockquote>
  <p><script type="math/tex" id="MathJax-Element-361">54.56</script> iteraciones, la medición se realizó corriendo el <code>pla</code> <script type="math/tex" id="MathJax-Element-362">1000</script> veces tomando muestras de tamaño <script type="math/tex" id="MathJax-Element-363">10</script> para los datos de entrenamiento.</p>
</blockquote>

<h5 id="2-cual-es-el-valor-de-eoutg-prf-x-6-g-x-para-el-algoritmo-del-perceptrón-con-10-valores-en-el-conjunto-de-aprendizaje-n-10">2. ¿Cual es el valor de <script type="math/tex" id="MathJax-Element-427">E_{out}(g ) = Pr(f (x) 6= g (x))</script> para el algoritmo del perceptrón con <script type="math/tex" id="MathJax-Element-428">10</script> valores en el conjunto de aprendizaje (<script type="math/tex" id="MathJax-Element-429">N = 10</script>).</h5>

<blockquote>
  <p><script type="math/tex" id="MathJax-Element-430">0.000510</script></p>
</blockquote>

<h5 id="3-cuantas-iteraciones-le-toma-en-promedio-al-algoritmo-del-perceptrón-en-converger-para-cien-valores-en-elconjunto-de-entrenamiento-n-100-para-tomar-un-número-promedio-de-iteraciones-hay-que-realizar-esto-al-menos-unas-100-veces">3. ¿Cuantas iteraciones le toma en promedio al algoritmo del perceptrón en converger, para cien valores en elconjunto de entrenamiento <script type="math/tex" id="MathJax-Element-399">N = 100</script>? Para tomar un número promedio de iteraciones hay que realizar esto al menos unas <script type="math/tex" id="MathJax-Element-400">100</script> veces.</h5>

<blockquote>
  <p><script type="math/tex" id="MathJax-Element-401">1759.437</script> iteraciones, la medición se realizó corriendo el <code>pla</code> <script type="math/tex" id="MathJax-Element-402">1000</script> veces tomando muestras de tamaño <script type="math/tex" id="MathJax-Element-403">100</script> para los datos de entrenamiento.</p>
</blockquote>

<h5 id="4-cual-es-el-valor-de-eoutg-prf-x-6-g-x-para-el-algoritmo-del-perceptrón-con-100-valores-en-el-conjunto-de-aprendizaje-n-100">4. ¿Cual es el valor de <script type="math/tex" id="MathJax-Element-438">E_{out}(g ) = Pr(f (x) 6= g (x))</script> para el algoritmo del perceptrón con <script type="math/tex" id="MathJax-Element-439">100</script> valores en el conjunto de aprendizaje (<script type="math/tex" id="MathJax-Element-440">N = 100</script>).</h5>

<blockquote>
  <p><script type="math/tex" id="MathJax-Element-441">2.0\times 10^{-5}</script></p>
</blockquote>

<h5 id="nota-los-programas-con-los-que-se-obtuvieron-estos-resultados-fueron"><strong>Nota:</strong> Los programas con los que se obtuvieron estos resultados fueron:</h5>



<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pla_avg_iterations</span>(<span class="hljs-title">sample_size</span>, <span class="hljs-title">n</span> = <span class="hljs-title">100</span>)</span>
  iterations = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> i <span class="hljs-operator">in</span> <span class="hljs-number">1</span>:n
    xs, ys, f = classified_data(sample_size)
    h, <span class="hljs-keyword">it</span> = pla(xs, ys)
    iterations += <span class="hljs-keyword">it</span>
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>

  <span class="hljs-constant">return</span> iterations/n
<span class="hljs-function"><span class="hljs-keyword">end</span></span></code></pre>

<p>y</p>



<pre class="prettyprint"><code class=" hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pla_avg_sample_error</span><span class="hljs-params">(sample_size, n = 100)</span></span>
  <span class="hljs-built_in">error</span> = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n
    xs, ys, f = classified_data(sample_size)
    h, iterations = pla(xs, ys)
    <span class="hljs-built_in">error</span> = out_sample_error(f, h)
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">error</span>/n
<span class="hljs-keyword">end</span></code></pre></div></body>
</html>